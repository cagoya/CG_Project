#version 330 core
out vec4 FragColor; // 输出的最终颜色

// 从顶点着色器接收的输入
in vec3 FragPos_worldspace;
in vec3 Normal_worldspace;
in vec2 TexCoords_FS;

// Uniform 变量
uniform sampler2D texture_diffuse1; // 漫反射纹理采样器
// uniform vec3 viewPos; // 如果需要镜面光照，可以传入相机位置 (世界空间)

// 如果的材质不仅仅是纹理，还可以定义其他uniform，例如:
// uniform vec3 u_objectBaseColor; // 一个基础颜色，可以与纹理混合
// uniform float u_materialShininess;
// uniform vec3 u_specularColor;

void main()
{
    // 1. 从纹理采样颜色
    vec4 texColor = texture(texture_diffuse1, TexCoords_FS);

    // 如果纹理的alpha值小于某个阈值，可以丢弃片段（例如用于透明贴图的镂空效果）
    // if(texColor.a < 0.1)
    //     discard;

    // 2. 光照计算 (一个简单的Blinn-Phong或仅漫反射光照模型)

    // 环境光
    float ambientStrength = 0.2; // 环境光强度 (可以作为uniform传入)
    // vec3 ambientLightColor = vec3(1.0, 1.0, 1.0); // 环境光颜色 (通常是场景全局的, 可以作为uniform传入)
    vec3 ambient = ambientStrength * texColor.rgb; // 环境光直接作用于纹理颜色

    // 漫反射光
    vec3 norm = normalize(Normal_worldspace);
    vec3 lightDir_worldspace = normalize(vec3(0.5, 1.0, 0.7)); // 定义一个固定的光源方向 (世界空间)
                                                              //  也可以将其作为uniform vec3从C++传入
    vec3 lightColor = vec3(1.0, 1.0, 1.0); // 光源颜色 (白色, 可以作为uniform传入)

    float diff = max(dot(norm, lightDir_worldspace), 0.0); // 计算漫反射因子
    vec3 diffuse = diff * lightColor * texColor.rgb; // 漫反射光作用于纹理颜色,并乘以光源颜色

    // (可选) 镜面光照 - 如果需要，取消注释并确保相关uniform (viewPos, u_materialShininess, u_specularColor) 已定义和传递
    /*
    float specularStrength = 0.5; // 镜面光强度 (可以作为uniform传入)
    vec3 viewDir_worldspace = normalize(viewPos - FragPos_worldspace); // 计算观察方向
    vec3 halfwayDir = normalize(lightDir_worldspace + viewDir_worldspace); // Blinn-Phong的半程向量
    // vec3 reflectDir = reflect(-lightDir_worldspace, norm); // Phong的反射向量
    // float spec = pow(max(dot(viewDir_worldspace, reflectDir), 0.0), u_materialShininess);
    float spec = pow(max(dot(norm, halfwayDir), 0.0), u_materialShininess); // u_materialShininess 比如 32.0
    vec3 specular = specularStrength * spec * lightColor * u_specularColor; // 镜面颜色通常是光源颜色乘以材质的镜面反射颜色
    */

    // 3. 最终颜色组合
    // vec3 resultColor = ambient + diffuse + specular; // 如果有镜面光
    vec3 resultColor = ambient + diffuse;

    FragColor = vec4(resultColor, texColor.a); // 使用纹理的alpha值作为最终颜色的alpha

    // --- 如果想暂时忽略光照，直接看纹理效果，可以取消下面这行的注释，并注释掉上面的光照和颜色组合 ---
    // FragColor = texColor;
}